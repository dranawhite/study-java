/**
 * 常用哈希算法
 * <pre>
 * 开放地址法
 *   线性探测法
 *   二次探测法
 *   再哈希法
 * 链地址法
 * </pre>
 * <pre>
 * 哈希算法小结
 * 1、哈希表基于数组
 * 2、关键字值的范围通常比数组容量大
 * 3、关键字值通过哈希函数映射为数组的下标
 * 4、英文字典是一个数据库的典型例子，它可以有效的用哈希表来处理
 * 5、一个关键字哈希化到已占用的数组单元，这种情况叫做冲突，也叫作哈希碰撞
 * 6、冲突可以用两种方法解决：开放地址法和链地址法
 * 7、在开放地址法中，把冲突的数据项放在数组的其它位置
 * 8、在链地址法中，每个数组单元包含一个链表，把所有映射到同一个数组下标的数据项都插到这个链表中
 * 9、在线性探测中，步长总是1，所以如果X是哈希函数计算得到的数组下标，那么探测序列就是X、X+1、X+2等
 * 10、在线性探测中，已填充单元的长度不断增加，它们叫做首次聚集，这会降低哈希表的性能
 * 11、在二次探测中，X的位移是步数的平方，所以探测序列就是X、X+1、X+4
 * 12、二次探测消除了首次聚集、但是产生了二次聚集、它比首次聚集危害略小(二次聚集是指如果一个数据总是发生碰撞，那么它每次探测的结果都是一样的)
 * 13、二次聚集的发生时因为所有映射到同一个单元的关键字，在探测过程中执行了相同的序列
 * 14、装填因子是表中数据项数和数组容量的比值
 * 15、开放地址法中的最大装填因子是在0.5附近，若有相同的装填因子，对于再哈希法来说，查找的平均探测长度是2
 * 16、在开放地址法中，当装填因子接近1时，查找时间趋于无限
 * 17、对于链地址法，装填因子为1比较合适，这时成功探测长度平均是1.5，不成功的则是2.0(探测长度是指查找的步数)
 * 18、字符串哈希化：每个字符乘以常数的不同次幂，求和，然后用取模操作符缩减结果，以适应哈希表的容量
 * 19、哈希表的容量通常是一个质数，这在二次探测和再哈希表中非常重要(主要是再探测时候避免重复)
 * 20、哈希表可以用于外部存储，相同hash值的数据放到同一个文件块中，如果文件块填满则哈希到其它的文件块
 * </pre>
 *
 * @author liangyq
 * @version [1.0, 2018/5/7 16:10]
 */
package com.study.algorithm.hash;