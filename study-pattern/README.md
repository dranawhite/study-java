##设计模式适用场景

###创建型
- 工厂模式、抽象工厂模式、工厂方法模式、静态工厂模式(Factory)
    > 关注于对象的创建
- 单例模式、多例模式(Singleton/Multiton)
- 建造者模式(Builder)
    > 关注于复杂对象的组装
- 原型模式(Prototype)
- 对象池模式(Pool)

###结构型
- 适配器模式(Adapter)
    > 当新增逻辑与现有逻辑相似但是参数不同时，做出入参适配
- 桥接模式(Bridge)
- 过滤器模式(Filter)
- 组合模式(Composite)
- 装饰器模式(Decorator)
- 外观模式(Facade)
- 享元模式(Flyweight)
- 代理模式(Proxy)
    > 在被代理的方法执行前后做一些额外的动作，如打印日志，统计执行耗时
- 数据映射模式(Data Mapper)
- 流接口模式(Fluent Interface)
- 注册模式(Registry)

###行为型
- 职责链模式(Chain of Responsibility)
    > 关注于业务职责的一整套链路，如Web的过滤器链、审批链
- 命令模式(Command)
- 解释器模式(Interpreter)
- 迭代器模式(Iterator)
- 中介者模式(Mediator)
- 备忘录模式(Memento)
- 观察者模式(Observer)
    > 发布/订阅模式，将订阅者列表保存起来，当发布新事件时，遍历挨个通知
- 状态模式(State)
    > 多个状态转换的状态机，如订单状态转换、审批流状态转换
- 空对象模式(Null Object)
    > 主要用于省去了对象判断的麻烦，可以与策略模式结合使用
- 策略模式(Strategy)
    > 传入不同的参数选择不同的实现类
- 模板模式(Template)
    > 抽象类中集成了业务规则的模板，把具体的细节留给子类实现
- 访问者模式(Visitor)
- 规格模式(Sepcification)

###J2EE设计模式(关注于表示层)
- MVC模式(MVC)
- 业务代表模式(Business Delegate)
- 组合实体模式(Composite Entity)
- 数据访问对象模式(Data Access Object)
- 前端控制器模式(Front Controller)
- 拦截过滤器模式(Intercepting Filter)
- 服务定位器模式(Service Locator)
- 传输对象模式(Transfer Object)
- 委托模式(Delegation)
- 资源库模式(Repository)

###六大设计原则
SOLID
 ##### 单一职责原则(SRP):
 - 只有一个原因能引起类或方法的改变；即一个类或者方法只应该做一件事；
 - 每个类应该有一个单一的功能，并且该功能应该由这个类完全封装起来。所有这个类的服务都应该严密的和该功能平行（即没有依赖）。保持一个类
 专注于单一功能点的一个重要原因是，它会使类更加健壮。假设两个功能存在于同一个类中，修改其中一个功能会导致公共状态或者依赖关系的改变，
 另一个功能从而不工作。
 
 ##### 开闭原则(OCP)：
 - 对扩展开放，对修改关闭；即软件尽量在不修改原有代码的基础上进行扩展。
 - 梅耶开闭原则：一个类的实现只应该因为错误而修改，新的或者改变的特性应该通过新建不同的类去实现。
 - 多态开闭原则：倡导对抽象类的继承，接口规约可以通过继承来重用，但是实现不必重用。实现可以被改变，已存在的接口对于修改是关闭的，并且新的实现必须实现那个接口
 - 实践：需求在变化时，重新定义新的实现类而不是修改接口或者抽象方法，从而达到尽量减少代码修改的目的
 
 ##### 里氏替换原则(LSP):
 - 能使用父类的地方，必然能够使用子类，反之则不成立；既子类必须完整的实现父类的方法
 - 如果子类不能完整的实现父类的方法或者父类的某些方法在子类中发生了畸变，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承；
  
 ##### 接口隔离原则(ISP)：
 - Client应该不依赖于它不使用的方法。接口隔离原则拆分非常庞大的臃肿的接口成为更小的和更具体的接口，这样Client将会只需要知道它们感兴
 趣的方法。这种缩小的接口也被称为角色接口。接口隔离原则的目的是系统解耦，从而容易重构，更改和重新部署。
 
 ##### 依赖倒置原则(DIP):
 - 高层模块不应该依赖于底层模块，两者都应该依赖于抽象；
 - 抽象不应该依赖于细节：抽象类不应该依赖于具体的实现类
 - 细节应该依赖于抽象；

 ##### 迪米特法则(LOD)——最小知道原则：
 - 一个类应该尽可能少的与其它实体相互作用
 - 实践：引入一个合理的第三者降低现有对象之间的耦合度

![设计模式关系图](docs/设计模式关系图.png)